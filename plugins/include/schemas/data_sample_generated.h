// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATASAMPLE_ROSS_DAMARIS_SAMPLE_H_
#define FLATBUFFERS_GENERATED_DATASAMPLE_ROSS_DAMARIS_SAMPLE_H_

#include "flatbuffers/flatbuffers.h"

#include "model_sample_generated.h"

namespace ross_damaris {
namespace sample {

struct SimEngineMetrics;
struct SimEngineMetricsT;

struct LPData;
struct LPDataT;

struct KPData;
struct KPDataT;

struct PEData;
struct PEDataT;

struct DamarisDataSample;
struct DamarisDataSampleT;

inline const flatbuffers::TypeTable *SimEngineMetricsTypeTable();

inline const flatbuffers::TypeTable *LPDataTypeTable();

inline const flatbuffers::TypeTable *KPDataTypeTable();

inline const flatbuffers::TypeTable *PEDataTypeTable();

inline const flatbuffers::TypeTable *DamarisDataSampleTypeTable();

/// To identify what instrumentation mode the data comes from
enum InstMode {
  InstMode_GVT = 0,
  InstMode_VT = 1,
  InstMode_RT = 2,
  InstMode_ET = 3,
  InstMode_MIN = InstMode_GVT,
  InstMode_MAX = InstMode_ET
};

inline const InstMode (&EnumValuesInstMode())[4] {
  static const InstMode values[] = {
    InstMode_GVT,
    InstMode_VT,
    InstMode_RT,
    InstMode_ET
  };
  return values;
}

inline const char * const *EnumNamesInstMode() {
  static const char * const names[] = {
    "GVT",
    "VT",
    "RT",
    "ET",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstMode(InstMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesInstMode()[index];
}

struct SimEngineMetricsT : public flatbuffers::NativeTable {
  typedef SimEngineMetrics TableType;
  int32_t nevent_processed;
  int32_t nevent_abort;
  int32_t nevent_rb;
  int32_t rb_total;
  int32_t rb_prim;
  int32_t rb_sec;
  int32_t fc_attempts;
  int32_t pq_qsize;
  int32_t network_send;
  int32_t network_recv;
  int32_t num_gvt;
  int32_t event_ties;
  float efficiency;
  float net_read_time;
  float net_other_time;
  float gvt_time;
  float fc_time;
  float event_abort_time;
  float event_proc_time;
  float pq_time;
  float rb_time;
  float cancel_q_time;
  float avl_time;
  float virtual_time_diff;
  SimEngineMetricsT()
      : nevent_processed(0),
        nevent_abort(0),
        nevent_rb(0),
        rb_total(0),
        rb_prim(0),
        rb_sec(0),
        fc_attempts(0),
        pq_qsize(0),
        network_send(0),
        network_recv(0),
        num_gvt(0),
        event_ties(0),
        efficiency(0.0f),
        net_read_time(0.0f),
        net_other_time(0.0f),
        gvt_time(0.0f),
        fc_time(0.0f),
        event_abort_time(0.0f),
        event_proc_time(0.0f),
        pq_time(0.0f),
        rb_time(0.0f),
        cancel_q_time(0.0f),
        avl_time(0.0f),
        virtual_time_diff(0.0f) {
  }
};

/// Sim engine metrics that are collected by Damaris
/// These should have the same variable names as supplied in Damaris XML file!
struct SimEngineMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimEngineMetricsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SimEngineMetricsTypeTable();
  }
  enum {
    VT_NEVENT_PROCESSED = 4,
    VT_NEVENT_ABORT = 6,
    VT_NEVENT_RB = 8,
    VT_RB_TOTAL = 10,
    VT_RB_PRIM = 12,
    VT_RB_SEC = 14,
    VT_FC_ATTEMPTS = 16,
    VT_PQ_QSIZE = 18,
    VT_NETWORK_SEND = 20,
    VT_NETWORK_RECV = 22,
    VT_NUM_GVT = 24,
    VT_EVENT_TIES = 26,
    VT_EFFICIENCY = 28,
    VT_NET_READ_TIME = 30,
    VT_NET_OTHER_TIME = 32,
    VT_GVT_TIME = 34,
    VT_FC_TIME = 36,
    VT_EVENT_ABORT_TIME = 38,
    VT_EVENT_PROC_TIME = 40,
    VT_PQ_TIME = 42,
    VT_RB_TIME = 44,
    VT_CANCEL_Q_TIME = 46,
    VT_AVL_TIME = 48,
    VT_VIRTUAL_TIME_DIFF = 50
  };
  int32_t nevent_processed() const {
    return GetField<int32_t>(VT_NEVENT_PROCESSED, 0);
  }
  int32_t nevent_abort() const {
    return GetField<int32_t>(VT_NEVENT_ABORT, 0);
  }
  int32_t nevent_rb() const {
    return GetField<int32_t>(VT_NEVENT_RB, 0);
  }
  int32_t rb_total() const {
    return GetField<int32_t>(VT_RB_TOTAL, 0);
  }
  int32_t rb_prim() const {
    return GetField<int32_t>(VT_RB_PRIM, 0);
  }
  int32_t rb_sec() const {
    return GetField<int32_t>(VT_RB_SEC, 0);
  }
  int32_t fc_attempts() const {
    return GetField<int32_t>(VT_FC_ATTEMPTS, 0);
  }
  int32_t pq_qsize() const {
    return GetField<int32_t>(VT_PQ_QSIZE, 0);
  }
  int32_t network_send() const {
    return GetField<int32_t>(VT_NETWORK_SEND, 0);
  }
  int32_t network_recv() const {
    return GetField<int32_t>(VT_NETWORK_RECV, 0);
  }
  int32_t num_gvt() const {
    return GetField<int32_t>(VT_NUM_GVT, 0);
  }
  int32_t event_ties() const {
    return GetField<int32_t>(VT_EVENT_TIES, 0);
  }
  float efficiency() const {
    return GetField<float>(VT_EFFICIENCY, 0.0f);
  }
  float net_read_time() const {
    return GetField<float>(VT_NET_READ_TIME, 0.0f);
  }
  float net_other_time() const {
    return GetField<float>(VT_NET_OTHER_TIME, 0.0f);
  }
  float gvt_time() const {
    return GetField<float>(VT_GVT_TIME, 0.0f);
  }
  float fc_time() const {
    return GetField<float>(VT_FC_TIME, 0.0f);
  }
  float event_abort_time() const {
    return GetField<float>(VT_EVENT_ABORT_TIME, 0.0f);
  }
  float event_proc_time() const {
    return GetField<float>(VT_EVENT_PROC_TIME, 0.0f);
  }
  float pq_time() const {
    return GetField<float>(VT_PQ_TIME, 0.0f);
  }
  float rb_time() const {
    return GetField<float>(VT_RB_TIME, 0.0f);
  }
  float cancel_q_time() const {
    return GetField<float>(VT_CANCEL_Q_TIME, 0.0f);
  }
  float avl_time() const {
    return GetField<float>(VT_AVL_TIME, 0.0f);
  }
  float virtual_time_diff() const {
    return GetField<float>(VT_VIRTUAL_TIME_DIFF, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NEVENT_PROCESSED) &&
           VerifyField<int32_t>(verifier, VT_NEVENT_ABORT) &&
           VerifyField<int32_t>(verifier, VT_NEVENT_RB) &&
           VerifyField<int32_t>(verifier, VT_RB_TOTAL) &&
           VerifyField<int32_t>(verifier, VT_RB_PRIM) &&
           VerifyField<int32_t>(verifier, VT_RB_SEC) &&
           VerifyField<int32_t>(verifier, VT_FC_ATTEMPTS) &&
           VerifyField<int32_t>(verifier, VT_PQ_QSIZE) &&
           VerifyField<int32_t>(verifier, VT_NETWORK_SEND) &&
           VerifyField<int32_t>(verifier, VT_NETWORK_RECV) &&
           VerifyField<int32_t>(verifier, VT_NUM_GVT) &&
           VerifyField<int32_t>(verifier, VT_EVENT_TIES) &&
           VerifyField<float>(verifier, VT_EFFICIENCY) &&
           VerifyField<float>(verifier, VT_NET_READ_TIME) &&
           VerifyField<float>(verifier, VT_NET_OTHER_TIME) &&
           VerifyField<float>(verifier, VT_GVT_TIME) &&
           VerifyField<float>(verifier, VT_FC_TIME) &&
           VerifyField<float>(verifier, VT_EVENT_ABORT_TIME) &&
           VerifyField<float>(verifier, VT_EVENT_PROC_TIME) &&
           VerifyField<float>(verifier, VT_PQ_TIME) &&
           VerifyField<float>(verifier, VT_RB_TIME) &&
           VerifyField<float>(verifier, VT_CANCEL_Q_TIME) &&
           VerifyField<float>(verifier, VT_AVL_TIME) &&
           VerifyField<float>(verifier, VT_VIRTUAL_TIME_DIFF) &&
           verifier.EndTable();
  }
  SimEngineMetricsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SimEngineMetricsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SimEngineMetrics> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SimEngineMetricsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nevent_processed(int32_t nevent_processed) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NEVENT_PROCESSED, nevent_processed, 0);
  }
  void add_nevent_abort(int32_t nevent_abort) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NEVENT_ABORT, nevent_abort, 0);
  }
  void add_nevent_rb(int32_t nevent_rb) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NEVENT_RB, nevent_rb, 0);
  }
  void add_rb_total(int32_t rb_total) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_RB_TOTAL, rb_total, 0);
  }
  void add_rb_prim(int32_t rb_prim) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_RB_PRIM, rb_prim, 0);
  }
  void add_rb_sec(int32_t rb_sec) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_RB_SEC, rb_sec, 0);
  }
  void add_fc_attempts(int32_t fc_attempts) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_FC_ATTEMPTS, fc_attempts, 0);
  }
  void add_pq_qsize(int32_t pq_qsize) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_PQ_QSIZE, pq_qsize, 0);
  }
  void add_network_send(int32_t network_send) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NETWORK_SEND, network_send, 0);
  }
  void add_network_recv(int32_t network_recv) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NETWORK_RECV, network_recv, 0);
  }
  void add_num_gvt(int32_t num_gvt) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NUM_GVT, num_gvt, 0);
  }
  void add_event_ties(int32_t event_ties) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_EVENT_TIES, event_ties, 0);
  }
  void add_efficiency(float efficiency) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_EFFICIENCY, efficiency, 0.0f);
  }
  void add_net_read_time(float net_read_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_NET_READ_TIME, net_read_time, 0.0f);
  }
  void add_net_other_time(float net_other_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_NET_OTHER_TIME, net_other_time, 0.0f);
  }
  void add_gvt_time(float gvt_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_GVT_TIME, gvt_time, 0.0f);
  }
  void add_fc_time(float fc_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_FC_TIME, fc_time, 0.0f);
  }
  void add_event_abort_time(float event_abort_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_EVENT_ABORT_TIME, event_abort_time, 0.0f);
  }
  void add_event_proc_time(float event_proc_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_EVENT_PROC_TIME, event_proc_time, 0.0f);
  }
  void add_pq_time(float pq_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_PQ_TIME, pq_time, 0.0f);
  }
  void add_rb_time(float rb_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_RB_TIME, rb_time, 0.0f);
  }
  void add_cancel_q_time(float cancel_q_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_CANCEL_Q_TIME, cancel_q_time, 0.0f);
  }
  void add_avl_time(float avl_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_AVL_TIME, avl_time, 0.0f);
  }
  void add_virtual_time_diff(float virtual_time_diff) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_VIRTUAL_TIME_DIFF, virtual_time_diff, 0.0f);
  }
  explicit SimEngineMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimEngineMetricsBuilder &operator=(const SimEngineMetricsBuilder &);
  flatbuffers::Offset<SimEngineMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimEngineMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimEngineMetrics> CreateSimEngineMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t nevent_processed = 0,
    int32_t nevent_abort = 0,
    int32_t nevent_rb = 0,
    int32_t rb_total = 0,
    int32_t rb_prim = 0,
    int32_t rb_sec = 0,
    int32_t fc_attempts = 0,
    int32_t pq_qsize = 0,
    int32_t network_send = 0,
    int32_t network_recv = 0,
    int32_t num_gvt = 0,
    int32_t event_ties = 0,
    float efficiency = 0.0f,
    float net_read_time = 0.0f,
    float net_other_time = 0.0f,
    float gvt_time = 0.0f,
    float fc_time = 0.0f,
    float event_abort_time = 0.0f,
    float event_proc_time = 0.0f,
    float pq_time = 0.0f,
    float rb_time = 0.0f,
    float cancel_q_time = 0.0f,
    float avl_time = 0.0f,
    float virtual_time_diff = 0.0f) {
  SimEngineMetricsBuilder builder_(_fbb);
  builder_.add_virtual_time_diff(virtual_time_diff);
  builder_.add_avl_time(avl_time);
  builder_.add_cancel_q_time(cancel_q_time);
  builder_.add_rb_time(rb_time);
  builder_.add_pq_time(pq_time);
  builder_.add_event_proc_time(event_proc_time);
  builder_.add_event_abort_time(event_abort_time);
  builder_.add_fc_time(fc_time);
  builder_.add_gvt_time(gvt_time);
  builder_.add_net_other_time(net_other_time);
  builder_.add_net_read_time(net_read_time);
  builder_.add_efficiency(efficiency);
  builder_.add_event_ties(event_ties);
  builder_.add_num_gvt(num_gvt);
  builder_.add_network_recv(network_recv);
  builder_.add_network_send(network_send);
  builder_.add_pq_qsize(pq_qsize);
  builder_.add_fc_attempts(fc_attempts);
  builder_.add_rb_sec(rb_sec);
  builder_.add_rb_prim(rb_prim);
  builder_.add_rb_total(rb_total);
  builder_.add_nevent_rb(nevent_rb);
  builder_.add_nevent_abort(nevent_abort);
  builder_.add_nevent_processed(nevent_processed);
  return builder_.Finish();
}

flatbuffers::Offset<SimEngineMetrics> CreateSimEngineMetrics(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LPDataT : public flatbuffers::NativeTable {
  typedef LPData TableType;
  int32_t peid;
  int32_t kpid;
  int32_t kp_gid;
  int32_t lpid;
  int32_t lp_gid;
  std::unique_ptr<SimEngineMetricsT> data;
  LPDataT()
      : peid(0),
        kpid(0),
        kp_gid(0),
        lpid(0),
        lp_gid(0) {
  }
};

struct LPData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LPDataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LPDataTypeTable();
  }
  enum {
    VT_PEID = 4,
    VT_KPID = 6,
    VT_KP_GID = 8,
    VT_LPID = 10,
    VT_LP_GID = 12,
    VT_DATA = 14
  };
  int32_t peid() const {
    return GetField<int32_t>(VT_PEID, 0);
  }
  int32_t kpid() const {
    return GetField<int32_t>(VT_KPID, 0);
  }
  int32_t kp_gid() const {
    return GetField<int32_t>(VT_KP_GID, 0);
  }
  int32_t lpid() const {
    return GetField<int32_t>(VT_LPID, 0);
  }
  int32_t lp_gid() const {
    return GetField<int32_t>(VT_LP_GID, 0);
  }
  const SimEngineMetrics *data() const {
    return GetPointer<const SimEngineMetrics *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEID) &&
           VerifyField<int32_t>(verifier, VT_KPID) &&
           VerifyField<int32_t>(verifier, VT_KP_GID) &&
           VerifyField<int32_t>(verifier, VT_LPID) &&
           VerifyField<int32_t>(verifier, VT_LP_GID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
  LPDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LPDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LPData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LPDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peid(int32_t peid) {
    fbb_.AddElement<int32_t>(LPData::VT_PEID, peid, 0);
  }
  void add_kpid(int32_t kpid) {
    fbb_.AddElement<int32_t>(LPData::VT_KPID, kpid, 0);
  }
  void add_kp_gid(int32_t kp_gid) {
    fbb_.AddElement<int32_t>(LPData::VT_KP_GID, kp_gid, 0);
  }
  void add_lpid(int32_t lpid) {
    fbb_.AddElement<int32_t>(LPData::VT_LPID, lpid, 0);
  }
  void add_lp_gid(int32_t lp_gid) {
    fbb_.AddElement<int32_t>(LPData::VT_LP_GID, lp_gid, 0);
  }
  void add_data(flatbuffers::Offset<SimEngineMetrics> data) {
    fbb_.AddOffset(LPData::VT_DATA, data);
  }
  explicit LPDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LPDataBuilder &operator=(const LPDataBuilder &);
  flatbuffers::Offset<LPData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LPData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LPData> CreateLPData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t peid = 0,
    int32_t kpid = 0,
    int32_t kp_gid = 0,
    int32_t lpid = 0,
    int32_t lp_gid = 0,
    flatbuffers::Offset<SimEngineMetrics> data = 0) {
  LPDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_lp_gid(lp_gid);
  builder_.add_lpid(lpid);
  builder_.add_kp_gid(kp_gid);
  builder_.add_kpid(kpid);
  builder_.add_peid(peid);
  return builder_.Finish();
}

flatbuffers::Offset<LPData> CreateLPData(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KPDataT : public flatbuffers::NativeTable {
  typedef KPData TableType;
  int32_t peid;
  int32_t kpid;
  int32_t kp_gid;
  std::unique_ptr<SimEngineMetricsT> data;
  KPDataT()
      : peid(0),
        kpid(0),
        kp_gid(0) {
  }
};

struct KPData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KPDataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KPDataTypeTable();
  }
  enum {
    VT_PEID = 4,
    VT_KPID = 6,
    VT_KP_GID = 8,
    VT_DATA = 10
  };
  int32_t peid() const {
    return GetField<int32_t>(VT_PEID, 0);
  }
  int32_t kpid() const {
    return GetField<int32_t>(VT_KPID, 0);
  }
  int32_t kp_gid() const {
    return GetField<int32_t>(VT_KP_GID, 0);
  }
  const SimEngineMetrics *data() const {
    return GetPointer<const SimEngineMetrics *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEID) &&
           VerifyField<int32_t>(verifier, VT_KPID) &&
           VerifyField<int32_t>(verifier, VT_KP_GID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
  KPDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KPDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KPData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KPDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peid(int32_t peid) {
    fbb_.AddElement<int32_t>(KPData::VT_PEID, peid, 0);
  }
  void add_kpid(int32_t kpid) {
    fbb_.AddElement<int32_t>(KPData::VT_KPID, kpid, 0);
  }
  void add_kp_gid(int32_t kp_gid) {
    fbb_.AddElement<int32_t>(KPData::VT_KP_GID, kp_gid, 0);
  }
  void add_data(flatbuffers::Offset<SimEngineMetrics> data) {
    fbb_.AddOffset(KPData::VT_DATA, data);
  }
  explicit KPDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KPDataBuilder &operator=(const KPDataBuilder &);
  flatbuffers::Offset<KPData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KPData>(end);
    return o;
  }
};

inline flatbuffers::Offset<KPData> CreateKPData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t peid = 0,
    int32_t kpid = 0,
    int32_t kp_gid = 0,
    flatbuffers::Offset<SimEngineMetrics> data = 0) {
  KPDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_kp_gid(kp_gid);
  builder_.add_kpid(kpid);
  builder_.add_peid(peid);
  return builder_.Finish();
}

flatbuffers::Offset<KPData> CreateKPData(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PEDataT : public flatbuffers::NativeTable {
  typedef PEData TableType;
  int32_t peid;
  std::unique_ptr<SimEngineMetricsT> data;
  PEDataT()
      : peid(0) {
  }
};

struct PEData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PEDataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PEDataTypeTable();
  }
  enum {
    VT_PEID = 4,
    VT_DATA = 6
  };
  int32_t peid() const {
    return GetField<int32_t>(VT_PEID, 0);
  }
  const SimEngineMetrics *data() const {
    return GetPointer<const SimEngineMetrics *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
  PEDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PEDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PEData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PEDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peid(int32_t peid) {
    fbb_.AddElement<int32_t>(PEData::VT_PEID, peid, 0);
  }
  void add_data(flatbuffers::Offset<SimEngineMetrics> data) {
    fbb_.AddOffset(PEData::VT_DATA, data);
  }
  explicit PEDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PEDataBuilder &operator=(const PEDataBuilder &);
  flatbuffers::Offset<PEData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PEData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PEData> CreatePEData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t peid = 0,
    flatbuffers::Offset<SimEngineMetrics> data = 0) {
  PEDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_peid(peid);
  return builder_.Finish();
}

flatbuffers::Offset<PEData> CreatePEData(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DamarisDataSampleT : public flatbuffers::NativeTable {
  typedef DamarisDataSample TableType;
  double virtual_ts;
  double real_ts;
  double last_gvt;
  InstMode mode;
  std::vector<std::unique_ptr<PEDataT>> pe_data;
  std::vector<std::unique_ptr<KPDataT>> kp_data;
  std::vector<std::unique_ptr<LPDataT>> lp_data;
  ModelData *model_data;
  DamarisDataSampleT()
      : virtual_ts(0.0),
        real_ts(0.0),
        last_gvt(0.0),
        mode(InstMode_GVT),
        model_data(nullptr) {
  }
};

struct DamarisDataSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DamarisDataSampleT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DamarisDataSampleTypeTable();
  }
  enum {
    VT_VIRTUAL_TS = 4,
    VT_REAL_TS = 6,
    VT_LAST_GVT = 8,
    VT_MODE = 10,
    VT_PE_DATA = 12,
    VT_KP_DATA = 14,
    VT_LP_DATA = 16,
    VT_MODEL_DATA = 18
  };
  double virtual_ts() const {
    return GetField<double>(VT_VIRTUAL_TS, 0.0);
  }
  double real_ts() const {
    return GetField<double>(VT_REAL_TS, 0.0);
  }
  double last_gvt() const {
    return GetField<double>(VT_LAST_GVT, 0.0);
  }
  InstMode mode() const {
    return static_cast<InstMode>(GetField<int32_t>(VT_MODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<PEData>> *pe_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PEData>> *>(VT_PE_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KPData>> *kp_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KPData>> *>(VT_KP_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LPData>> *lp_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LPData>> *>(VT_LP_DATA);
  }
  int32_t model_data() const {
    return GetField<int32_t>(VT_MODEL_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VIRTUAL_TS) &&
           VerifyField<double>(verifier, VT_REAL_TS) &&
           VerifyField<double>(verifier, VT_LAST_GVT) &&
           VerifyField<int32_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_PE_DATA) &&
           verifier.VerifyVector(pe_data()) &&
           verifier.VerifyVectorOfTables(pe_data()) &&
           VerifyOffset(verifier, VT_KP_DATA) &&
           verifier.VerifyVector(kp_data()) &&
           verifier.VerifyVectorOfTables(kp_data()) &&
           VerifyOffset(verifier, VT_LP_DATA) &&
           verifier.VerifyVector(lp_data()) &&
           verifier.VerifyVectorOfTables(lp_data()) &&
           VerifyField<int32_t>(verifier, VT_MODEL_DATA) &&
           verifier.EndTable();
  }
  DamarisDataSampleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DamarisDataSampleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DamarisDataSample> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DamarisDataSampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_virtual_ts(double virtual_ts) {
    fbb_.AddElement<double>(DamarisDataSample::VT_VIRTUAL_TS, virtual_ts, 0.0);
  }
  void add_real_ts(double real_ts) {
    fbb_.AddElement<double>(DamarisDataSample::VT_REAL_TS, real_ts, 0.0);
  }
  void add_last_gvt(double last_gvt) {
    fbb_.AddElement<double>(DamarisDataSample::VT_LAST_GVT, last_gvt, 0.0);
  }
  void add_mode(InstMode mode) {
    fbb_.AddElement<int32_t>(DamarisDataSample::VT_MODE, static_cast<int32_t>(mode), 0);
  }
  void add_pe_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PEData>>> pe_data) {
    fbb_.AddOffset(DamarisDataSample::VT_PE_DATA, pe_data);
  }
  void add_kp_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KPData>>> kp_data) {
    fbb_.AddOffset(DamarisDataSample::VT_KP_DATA, kp_data);
  }
  void add_lp_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LPData>>> lp_data) {
    fbb_.AddOffset(DamarisDataSample::VT_LP_DATA, lp_data);
  }
  void add_model_data(int32_t model_data) {
    fbb_.AddElement<int32_t>(DamarisDataSample::VT_MODEL_DATA, model_data, 0);
  }
  explicit DamarisDataSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DamarisDataSampleBuilder &operator=(const DamarisDataSampleBuilder &);
  flatbuffers::Offset<DamarisDataSample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DamarisDataSample>(end);
    return o;
  }
};

inline flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSample(
    flatbuffers::FlatBufferBuilder &_fbb,
    double virtual_ts = 0.0,
    double real_ts = 0.0,
    double last_gvt = 0.0,
    InstMode mode = InstMode_GVT,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PEData>>> pe_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KPData>>> kp_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LPData>>> lp_data = 0,
    int32_t model_data = 0) {
  DamarisDataSampleBuilder builder_(_fbb);
  builder_.add_last_gvt(last_gvt);
  builder_.add_real_ts(real_ts);
  builder_.add_virtual_ts(virtual_ts);
  builder_.add_model_data(model_data);
  builder_.add_lp_data(lp_data);
  builder_.add_kp_data(kp_data);
  builder_.add_pe_data(pe_data);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double virtual_ts = 0.0,
    double real_ts = 0.0,
    double last_gvt = 0.0,
    InstMode mode = InstMode_GVT,
    const std::vector<flatbuffers::Offset<PEData>> *pe_data = nullptr,
    const std::vector<flatbuffers::Offset<KPData>> *kp_data = nullptr,
    const std::vector<flatbuffers::Offset<LPData>> *lp_data = nullptr,
    int32_t model_data = 0) {
  return ross_damaris::sample::CreateDamarisDataSample(
      _fbb,
      virtual_ts,
      real_ts,
      last_gvt,
      mode,
      pe_data ? _fbb.CreateVector<flatbuffers::Offset<PEData>>(*pe_data) : 0,
      kp_data ? _fbb.CreateVector<flatbuffers::Offset<KPData>>(*kp_data) : 0,
      lp_data ? _fbb.CreateVector<flatbuffers::Offset<LPData>>(*lp_data) : 0,
      model_data);
}

flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSample(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SimEngineMetricsT *SimEngineMetrics::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SimEngineMetricsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SimEngineMetrics::UnPackTo(SimEngineMetricsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nevent_processed(); _o->nevent_processed = _e; };
  { auto _e = nevent_abort(); _o->nevent_abort = _e; };
  { auto _e = nevent_rb(); _o->nevent_rb = _e; };
  { auto _e = rb_total(); _o->rb_total = _e; };
  { auto _e = rb_prim(); _o->rb_prim = _e; };
  { auto _e = rb_sec(); _o->rb_sec = _e; };
  { auto _e = fc_attempts(); _o->fc_attempts = _e; };
  { auto _e = pq_qsize(); _o->pq_qsize = _e; };
  { auto _e = network_send(); _o->network_send = _e; };
  { auto _e = network_recv(); _o->network_recv = _e; };
  { auto _e = num_gvt(); _o->num_gvt = _e; };
  { auto _e = event_ties(); _o->event_ties = _e; };
  { auto _e = efficiency(); _o->efficiency = _e; };
  { auto _e = net_read_time(); _o->net_read_time = _e; };
  { auto _e = net_other_time(); _o->net_other_time = _e; };
  { auto _e = gvt_time(); _o->gvt_time = _e; };
  { auto _e = fc_time(); _o->fc_time = _e; };
  { auto _e = event_abort_time(); _o->event_abort_time = _e; };
  { auto _e = event_proc_time(); _o->event_proc_time = _e; };
  { auto _e = pq_time(); _o->pq_time = _e; };
  { auto _e = rb_time(); _o->rb_time = _e; };
  { auto _e = cancel_q_time(); _o->cancel_q_time = _e; };
  { auto _e = avl_time(); _o->avl_time = _e; };
  { auto _e = virtual_time_diff(); _o->virtual_time_diff = _e; };
}

inline flatbuffers::Offset<SimEngineMetrics> SimEngineMetrics::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSimEngineMetrics(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SimEngineMetrics> CreateSimEngineMetrics(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SimEngineMetricsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nevent_processed = _o->nevent_processed;
  auto _nevent_abort = _o->nevent_abort;
  auto _nevent_rb = _o->nevent_rb;
  auto _rb_total = _o->rb_total;
  auto _rb_prim = _o->rb_prim;
  auto _rb_sec = _o->rb_sec;
  auto _fc_attempts = _o->fc_attempts;
  auto _pq_qsize = _o->pq_qsize;
  auto _network_send = _o->network_send;
  auto _network_recv = _o->network_recv;
  auto _num_gvt = _o->num_gvt;
  auto _event_ties = _o->event_ties;
  auto _efficiency = _o->efficiency;
  auto _net_read_time = _o->net_read_time;
  auto _net_other_time = _o->net_other_time;
  auto _gvt_time = _o->gvt_time;
  auto _fc_time = _o->fc_time;
  auto _event_abort_time = _o->event_abort_time;
  auto _event_proc_time = _o->event_proc_time;
  auto _pq_time = _o->pq_time;
  auto _rb_time = _o->rb_time;
  auto _cancel_q_time = _o->cancel_q_time;
  auto _avl_time = _o->avl_time;
  auto _virtual_time_diff = _o->virtual_time_diff;
  return ross_damaris::sample::CreateSimEngineMetrics(
      _fbb,
      _nevent_processed,
      _nevent_abort,
      _nevent_rb,
      _rb_total,
      _rb_prim,
      _rb_sec,
      _fc_attempts,
      _pq_qsize,
      _network_send,
      _network_recv,
      _num_gvt,
      _event_ties,
      _efficiency,
      _net_read_time,
      _net_other_time,
      _gvt_time,
      _fc_time,
      _event_abort_time,
      _event_proc_time,
      _pq_time,
      _rb_time,
      _cancel_q_time,
      _avl_time,
      _virtual_time_diff);
}

inline LPDataT *LPData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LPDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LPData::UnPackTo(LPDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peid(); _o->peid = _e; };
  { auto _e = kpid(); _o->kpid = _e; };
  { auto _e = kp_gid(); _o->kp_gid = _e; };
  { auto _e = lpid(); _o->lpid = _e; };
  { auto _e = lp_gid(); _o->lp_gid = _e; };
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<SimEngineMetricsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<LPData> LPData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLPData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LPData> CreateLPData(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LPDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peid = _o->peid;
  auto _kpid = _o->kpid;
  auto _kp_gid = _o->kp_gid;
  auto _lpid = _o->lpid;
  auto _lp_gid = _o->lp_gid;
  auto _data = _o->data ? CreateSimEngineMetrics(_fbb, _o->data.get(), _rehasher) : 0;
  return ross_damaris::sample::CreateLPData(
      _fbb,
      _peid,
      _kpid,
      _kp_gid,
      _lpid,
      _lp_gid,
      _data);
}

inline KPDataT *KPData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KPDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KPData::UnPackTo(KPDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peid(); _o->peid = _e; };
  { auto _e = kpid(); _o->kpid = _e; };
  { auto _e = kp_gid(); _o->kp_gid = _e; };
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<SimEngineMetricsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<KPData> KPData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKPData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KPData> CreateKPData(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KPDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peid = _o->peid;
  auto _kpid = _o->kpid;
  auto _kp_gid = _o->kp_gid;
  auto _data = _o->data ? CreateSimEngineMetrics(_fbb, _o->data.get(), _rehasher) : 0;
  return ross_damaris::sample::CreateKPData(
      _fbb,
      _peid,
      _kpid,
      _kp_gid,
      _data);
}

inline PEDataT *PEData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PEDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PEData::UnPackTo(PEDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peid(); _o->peid = _e; };
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<SimEngineMetricsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<PEData> PEData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePEData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PEData> CreatePEData(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PEDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peid = _o->peid;
  auto _data = _o->data ? CreateSimEngineMetrics(_fbb, _o->data.get(), _rehasher) : 0;
  return ross_damaris::sample::CreatePEData(
      _fbb,
      _peid,
      _data);
}

inline DamarisDataSampleT *DamarisDataSample::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DamarisDataSampleT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DamarisDataSample::UnPackTo(DamarisDataSampleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = virtual_ts(); _o->virtual_ts = _e; };
  { auto _e = real_ts(); _o->real_ts = _e; };
  { auto _e = last_gvt(); _o->last_gvt = _e; };
  { auto _e = mode(); _o->mode = _e; };
  { auto _e = pe_data(); if (_e) { _o->pe_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pe_data[_i] = std::unique_ptr<PEDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kp_data(); if (_e) { _o->kp_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kp_data[_i] = std::unique_ptr<KPDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = lp_data(); if (_e) { _o->lp_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lp_data[_i] = std::unique_ptr<LPDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = model_data(); //scalar resolver, naked 
if (_resolver) (*_resolver)(reinterpret_cast<void **>(&_o->model_data), static_cast<flatbuffers::hash_value_t>(_e)); else _o->model_data = nullptr; };
}

inline flatbuffers::Offset<DamarisDataSample> DamarisDataSample::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDamarisDataSample(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSample(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DamarisDataSampleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _virtual_ts = _o->virtual_ts;
  auto _real_ts = _o->real_ts;
  auto _last_gvt = _o->last_gvt;
  auto _mode = _o->mode;
  auto _pe_data = _o->pe_data.size() ? _fbb.CreateVector<flatbuffers::Offset<PEData>> (_o->pe_data.size(), [](size_t i, _VectorArgs *__va) { return CreatePEData(*__va->__fbb, __va->__o->pe_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kp_data = _o->kp_data.size() ? _fbb.CreateVector<flatbuffers::Offset<KPData>> (_o->kp_data.size(), [](size_t i, _VectorArgs *__va) { return CreateKPData(*__va->__fbb, __va->__o->kp_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lp_data = _o->lp_data.size() ? _fbb.CreateVector<flatbuffers::Offset<LPData>> (_o->lp_data.size(), [](size_t i, _VectorArgs *__va) { return CreateLPData(*__va->__fbb, __va->__o->lp_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _model_data = _rehasher ? static_cast<int32_t>((*_rehasher)(_o->model_data)) : 0;
  return ross_damaris::sample::CreateDamarisDataSample(
      _fbb,
      _virtual_ts,
      _real_ts,
      _last_gvt,
      _mode,
      _pe_data,
      _kp_data,
      _lp_data,
      _model_data);
}

inline const flatbuffers::TypeTable *InstModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    InstModeTypeTable
  };
  static const char * const names[] = {
    "GVT",
    "VT",
    "RT",
    "ET"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SimEngineMetricsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "nevent_processed",
    "nevent_abort",
    "nevent_rb",
    "rb_total",
    "rb_prim",
    "rb_sec",
    "fc_attempts",
    "pq_qsize",
    "network_send",
    "network_recv",
    "num_gvt",
    "event_ties",
    "efficiency",
    "net_read_time",
    "net_other_time",
    "gvt_time",
    "fc_time",
    "event_abort_time",
    "event_proc_time",
    "pq_time",
    "rb_time",
    "cancel_q_time",
    "avl_time",
    "virtual_time_diff"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 24, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LPDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SimEngineMetricsTypeTable
  };
  static const char * const names[] = {
    "peid",
    "kpid",
    "kp_gid",
    "lpid",
    "lp_gid",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KPDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SimEngineMetricsTypeTable
  };
  static const char * const names[] = {
    "peid",
    "kpid",
    "kp_gid",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PEDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SimEngineMetricsTypeTable
  };
  static const char * const names[] = {
    "peid",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DamarisDataSampleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    InstModeTypeTable,
    PEDataTypeTable,
    KPDataTypeTable,
    LPDataTypeTable
  };
  static const char * const names[] = {
    "virtual_ts",
    "real_ts",
    "last_gvt",
    "mode",
    "pe_data",
    "kp_data",
    "lp_data",
    "model_data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const ross_damaris::sample::DamarisDataSample *GetDamarisDataSample(const void *buf) {
  return flatbuffers::GetRoot<ross_damaris::sample::DamarisDataSample>(buf);
}

inline const ross_damaris::sample::DamarisDataSample *GetSizePrefixedDamarisDataSample(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ross_damaris::sample::DamarisDataSample>(buf);
}

inline bool VerifyDamarisDataSampleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ross_damaris::sample::DamarisDataSample>(nullptr);
}

inline bool VerifySizePrefixedDamarisDataSampleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ross_damaris::sample::DamarisDataSample>(nullptr);
}

inline void FinishDamarisDataSampleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ross_damaris::sample::DamarisDataSample> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDamarisDataSampleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ross_damaris::sample::DamarisDataSample> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<DamarisDataSampleT> UnPackDamarisDataSample(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DamarisDataSampleT>(GetDamarisDataSample(buf)->UnPack(res));
}

}  // namespace sample
}  // namespace ross_damaris

#endif  // FLATBUFFERS_GENERATED_DATASAMPLE_ROSS_DAMARIS_SAMPLE_H_
