// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATASAMPLE_ROSS_DAMARIS_SAMPLE_H_
#define FLATBUFFERS_GENERATED_DATASAMPLE_ROSS_DAMARIS_SAMPLE_H_

#include "flatbuffers/flatbuffers.h"

namespace ross_damaris {
namespace sample {

struct SimEngineMetrics;
struct SimEngineMetricsT;

struct LPData;
struct LPDataT;

struct KPData;
struct KPDataT;

struct PEData;
struct PEDataT;

struct IntVar;
struct IntVarT;

struct LongVar;
struct LongVarT;

struct FloatVar;
struct FloatVarT;

struct DoubleVar;
struct DoubleVarT;

struct ModelVariable;
struct ModelVariableT;

struct ModelLP;
struct ModelLPT;

struct DamarisDataSample;
struct DamarisDataSampleT;

inline const flatbuffers::TypeTable *SimEngineMetricsTypeTable();

inline const flatbuffers::TypeTable *LPDataTypeTable();

inline const flatbuffers::TypeTable *KPDataTypeTable();

inline const flatbuffers::TypeTable *PEDataTypeTable();

inline const flatbuffers::TypeTable *IntVarTypeTable();

inline const flatbuffers::TypeTable *LongVarTypeTable();

inline const flatbuffers::TypeTable *FloatVarTypeTable();

inline const flatbuffers::TypeTable *DoubleVarTypeTable();

inline const flatbuffers::TypeTable *ModelVariableTypeTable();

inline const flatbuffers::TypeTable *ModelLPTypeTable();

inline const flatbuffers::TypeTable *DamarisDataSampleTypeTable();

/// To identify what instrumentation mode the data comes from
enum InstMode {
  InstMode_none = 0,
  InstMode_GVT = 1,
  InstMode_VT = 2,
  InstMode_RT = 3,
  InstMode_ET = 4,
  InstMode_MIN = InstMode_none,
  InstMode_MAX = InstMode_ET
};

inline const InstMode (&EnumValuesInstMode())[5] {
  static const InstMode values[] = {
    InstMode_none,
    InstMode_GVT,
    InstMode_VT,
    InstMode_RT,
    InstMode_ET
  };
  return values;
}

inline const char * const *EnumNamesInstMode() {
  static const char * const names[] = {
    "none",
    "GVT",
    "VT",
    "RT",
    "ET",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstMode(InstMode e) {
  if (e < InstMode_none || e > InstMode_ET) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesInstMode()[index];
}

/// To determine the status of a particular data sample
enum DataStatus {
  DataStatus_speculative = 0,
  DataStatus_committed = 1,
  DataStatus_invalid = 2,
  DataStatus_MIN = DataStatus_speculative,
  DataStatus_MAX = DataStatus_invalid
};

inline const DataStatus (&EnumValuesDataStatus())[3] {
  static const DataStatus values[] = {
    DataStatus_speculative,
    DataStatus_committed,
    DataStatus_invalid
  };
  return values;
}

inline const char * const *EnumNamesDataStatus() {
  static const char * const names[] = {
    "speculative",
    "committed",
    "invalid",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataStatus(DataStatus e) {
  if (e < DataStatus_speculative || e > DataStatus_invalid) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesDataStatus()[index];
}

/// To be used by model metrics
enum VariableType {
  VariableType_NONE = 0,
  VariableType_IntVar = 1,
  VariableType_LongVar = 2,
  VariableType_FloatVar = 3,
  VariableType_DoubleVar = 4,
  VariableType_MIN = VariableType_NONE,
  VariableType_MAX = VariableType_DoubleVar
};

inline const VariableType (&EnumValuesVariableType())[5] {
  static const VariableType values[] = {
    VariableType_NONE,
    VariableType_IntVar,
    VariableType_LongVar,
    VariableType_FloatVar,
    VariableType_DoubleVar
  };
  return values;
}

inline const char * const *EnumNamesVariableType() {
  static const char * const names[] = {
    "NONE",
    "IntVar",
    "LongVar",
    "FloatVar",
    "DoubleVar",
    nullptr
  };
  return names;
}

inline const char *EnumNameVariableType(VariableType e) {
  if (e < VariableType_NONE || e > VariableType_DoubleVar) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesVariableType()[index];
}

template<typename T> struct VariableTypeTraits {
  static const VariableType enum_value = VariableType_NONE;
};

template<> struct VariableTypeTraits<IntVar> {
  static const VariableType enum_value = VariableType_IntVar;
};

template<> struct VariableTypeTraits<LongVar> {
  static const VariableType enum_value = VariableType_LongVar;
};

template<> struct VariableTypeTraits<FloatVar> {
  static const VariableType enum_value = VariableType_FloatVar;
};

template<> struct VariableTypeTraits<DoubleVar> {
  static const VariableType enum_value = VariableType_DoubleVar;
};

struct VariableTypeUnion {
  VariableType type;
  void *value;

  VariableTypeUnion() : type(VariableType_NONE), value(nullptr) {}
  VariableTypeUnion(VariableTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(VariableType_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  VariableTypeUnion(const VariableTypeUnion &) FLATBUFFERS_NOEXCEPT;
  VariableTypeUnion &operator=(const VariableTypeUnion &u) FLATBUFFERS_NOEXCEPT
    { VariableTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  VariableTypeUnion &operator=(VariableTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~VariableTypeUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = VariableTypeTraits<typename T::TableType>::enum_value;
    if (type != VariableType_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, VariableType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  IntVarT *AsIntVar() {
    return type == VariableType_IntVar ?
      reinterpret_cast<IntVarT *>(value) : nullptr;
  }
  const IntVarT *AsIntVar() const {
    return type == VariableType_IntVar ?
      reinterpret_cast<const IntVarT *>(value) : nullptr;
  }
  LongVarT *AsLongVar() {
    return type == VariableType_LongVar ?
      reinterpret_cast<LongVarT *>(value) : nullptr;
  }
  const LongVarT *AsLongVar() const {
    return type == VariableType_LongVar ?
      reinterpret_cast<const LongVarT *>(value) : nullptr;
  }
  FloatVarT *AsFloatVar() {
    return type == VariableType_FloatVar ?
      reinterpret_cast<FloatVarT *>(value) : nullptr;
  }
  const FloatVarT *AsFloatVar() const {
    return type == VariableType_FloatVar ?
      reinterpret_cast<const FloatVarT *>(value) : nullptr;
  }
  DoubleVarT *AsDoubleVar() {
    return type == VariableType_DoubleVar ?
      reinterpret_cast<DoubleVarT *>(value) : nullptr;
  }
  const DoubleVarT *AsDoubleVar() const {
    return type == VariableType_DoubleVar ?
      reinterpret_cast<const DoubleVarT *>(value) : nullptr;
  }
};

bool VerifyVariableType(flatbuffers::Verifier &verifier, const void *obj, VariableType type);
bool VerifyVariableTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct SimEngineMetricsT : public flatbuffers::NativeTable {
  typedef SimEngineMetrics TableType;
  int32_t nevent_processed;
  int32_t nevent_abort;
  int32_t nevent_rb;
  int32_t rb_total;
  int32_t rb_prim;
  int32_t rb_sec;
  int32_t fc_attempts;
  int32_t pq_qsize;
  int32_t network_send;
  int32_t network_recv;
  int32_t num_gvt;
  int32_t event_ties;
  float efficiency;
  float net_read_time;
  float net_other_time;
  float gvt_time;
  float fc_time;
  float event_abort_time;
  float event_proc_time;
  float pq_time;
  float rb_time;
  float cancel_q_time;
  float avl_time;
  float virtual_time_diff;
  std::vector<int32_t> comm_data;
  SimEngineMetricsT()
      : nevent_processed(0),
        nevent_abort(0),
        nevent_rb(0),
        rb_total(0),
        rb_prim(0),
        rb_sec(0),
        fc_attempts(0),
        pq_qsize(0),
        network_send(0),
        network_recv(0),
        num_gvt(0),
        event_ties(0),
        efficiency(0.0f),
        net_read_time(0.0f),
        net_other_time(0.0f),
        gvt_time(0.0f),
        fc_time(0.0f),
        event_abort_time(0.0f),
        event_proc_time(0.0f),
        pq_time(0.0f),
        rb_time(0.0f),
        cancel_q_time(0.0f),
        avl_time(0.0f),
        virtual_time_diff(0.0f) {
  }
};

/// Sim engine metrics that are collected by ROSS instrumentation
struct SimEngineMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimEngineMetricsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SimEngineMetricsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEVENT_PROCESSED = 4,
    VT_NEVENT_ABORT = 6,
    VT_NEVENT_RB = 8,
    VT_RB_TOTAL = 10,
    VT_RB_PRIM = 12,
    VT_RB_SEC = 14,
    VT_FC_ATTEMPTS = 16,
    VT_PQ_QSIZE = 18,
    VT_NETWORK_SEND = 20,
    VT_NETWORK_RECV = 22,
    VT_NUM_GVT = 24,
    VT_EVENT_TIES = 26,
    VT_EFFICIENCY = 28,
    VT_NET_READ_TIME = 30,
    VT_NET_OTHER_TIME = 32,
    VT_GVT_TIME = 34,
    VT_FC_TIME = 36,
    VT_EVENT_ABORT_TIME = 38,
    VT_EVENT_PROC_TIME = 40,
    VT_PQ_TIME = 42,
    VT_RB_TIME = 44,
    VT_CANCEL_Q_TIME = 46,
    VT_AVL_TIME = 48,
    VT_VIRTUAL_TIME_DIFF = 50,
    VT_COMM_DATA = 52
  };
  int32_t nevent_processed() const {
    return GetField<int32_t>(VT_NEVENT_PROCESSED, 0);
  }
  int32_t nevent_abort() const {
    return GetField<int32_t>(VT_NEVENT_ABORT, 0);
  }
  int32_t nevent_rb() const {
    return GetField<int32_t>(VT_NEVENT_RB, 0);
  }
  int32_t rb_total() const {
    return GetField<int32_t>(VT_RB_TOTAL, 0);
  }
  int32_t rb_prim() const {
    return GetField<int32_t>(VT_RB_PRIM, 0);
  }
  int32_t rb_sec() const {
    return GetField<int32_t>(VT_RB_SEC, 0);
  }
  int32_t fc_attempts() const {
    return GetField<int32_t>(VT_FC_ATTEMPTS, 0);
  }
  int32_t pq_qsize() const {
    return GetField<int32_t>(VT_PQ_QSIZE, 0);
  }
  int32_t network_send() const {
    return GetField<int32_t>(VT_NETWORK_SEND, 0);
  }
  int32_t network_recv() const {
    return GetField<int32_t>(VT_NETWORK_RECV, 0);
  }
  int32_t num_gvt() const {
    return GetField<int32_t>(VT_NUM_GVT, 0);
  }
  int32_t event_ties() const {
    return GetField<int32_t>(VT_EVENT_TIES, 0);
  }
  float efficiency() const {
    return GetField<float>(VT_EFFICIENCY, 0.0f);
  }
  float net_read_time() const {
    return GetField<float>(VT_NET_READ_TIME, 0.0f);
  }
  float net_other_time() const {
    return GetField<float>(VT_NET_OTHER_TIME, 0.0f);
  }
  float gvt_time() const {
    return GetField<float>(VT_GVT_TIME, 0.0f);
  }
  float fc_time() const {
    return GetField<float>(VT_FC_TIME, 0.0f);
  }
  float event_abort_time() const {
    return GetField<float>(VT_EVENT_ABORT_TIME, 0.0f);
  }
  float event_proc_time() const {
    return GetField<float>(VT_EVENT_PROC_TIME, 0.0f);
  }
  float pq_time() const {
    return GetField<float>(VT_PQ_TIME, 0.0f);
  }
  float rb_time() const {
    return GetField<float>(VT_RB_TIME, 0.0f);
  }
  float cancel_q_time() const {
    return GetField<float>(VT_CANCEL_Q_TIME, 0.0f);
  }
  float avl_time() const {
    return GetField<float>(VT_AVL_TIME, 0.0f);
  }
  float virtual_time_diff() const {
    return GetField<float>(VT_VIRTUAL_TIME_DIFF, 0.0f);
  }
  const flatbuffers::Vector<int32_t> *comm_data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_COMM_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NEVENT_PROCESSED) &&
           VerifyField<int32_t>(verifier, VT_NEVENT_ABORT) &&
           VerifyField<int32_t>(verifier, VT_NEVENT_RB) &&
           VerifyField<int32_t>(verifier, VT_RB_TOTAL) &&
           VerifyField<int32_t>(verifier, VT_RB_PRIM) &&
           VerifyField<int32_t>(verifier, VT_RB_SEC) &&
           VerifyField<int32_t>(verifier, VT_FC_ATTEMPTS) &&
           VerifyField<int32_t>(verifier, VT_PQ_QSIZE) &&
           VerifyField<int32_t>(verifier, VT_NETWORK_SEND) &&
           VerifyField<int32_t>(verifier, VT_NETWORK_RECV) &&
           VerifyField<int32_t>(verifier, VT_NUM_GVT) &&
           VerifyField<int32_t>(verifier, VT_EVENT_TIES) &&
           VerifyField<float>(verifier, VT_EFFICIENCY) &&
           VerifyField<float>(verifier, VT_NET_READ_TIME) &&
           VerifyField<float>(verifier, VT_NET_OTHER_TIME) &&
           VerifyField<float>(verifier, VT_GVT_TIME) &&
           VerifyField<float>(verifier, VT_FC_TIME) &&
           VerifyField<float>(verifier, VT_EVENT_ABORT_TIME) &&
           VerifyField<float>(verifier, VT_EVENT_PROC_TIME) &&
           VerifyField<float>(verifier, VT_PQ_TIME) &&
           VerifyField<float>(verifier, VT_RB_TIME) &&
           VerifyField<float>(verifier, VT_CANCEL_Q_TIME) &&
           VerifyField<float>(verifier, VT_AVL_TIME) &&
           VerifyField<float>(verifier, VT_VIRTUAL_TIME_DIFF) &&
           VerifyOffset(verifier, VT_COMM_DATA) &&
           verifier.VerifyVector(comm_data()) &&
           verifier.EndTable();
  }
  SimEngineMetricsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SimEngineMetricsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SimEngineMetrics> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SimEngineMetricsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nevent_processed(int32_t nevent_processed) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NEVENT_PROCESSED, nevent_processed, 0);
  }
  void add_nevent_abort(int32_t nevent_abort) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NEVENT_ABORT, nevent_abort, 0);
  }
  void add_nevent_rb(int32_t nevent_rb) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NEVENT_RB, nevent_rb, 0);
  }
  void add_rb_total(int32_t rb_total) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_RB_TOTAL, rb_total, 0);
  }
  void add_rb_prim(int32_t rb_prim) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_RB_PRIM, rb_prim, 0);
  }
  void add_rb_sec(int32_t rb_sec) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_RB_SEC, rb_sec, 0);
  }
  void add_fc_attempts(int32_t fc_attempts) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_FC_ATTEMPTS, fc_attempts, 0);
  }
  void add_pq_qsize(int32_t pq_qsize) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_PQ_QSIZE, pq_qsize, 0);
  }
  void add_network_send(int32_t network_send) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NETWORK_SEND, network_send, 0);
  }
  void add_network_recv(int32_t network_recv) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NETWORK_RECV, network_recv, 0);
  }
  void add_num_gvt(int32_t num_gvt) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_NUM_GVT, num_gvt, 0);
  }
  void add_event_ties(int32_t event_ties) {
    fbb_.AddElement<int32_t>(SimEngineMetrics::VT_EVENT_TIES, event_ties, 0);
  }
  void add_efficiency(float efficiency) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_EFFICIENCY, efficiency, 0.0f);
  }
  void add_net_read_time(float net_read_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_NET_READ_TIME, net_read_time, 0.0f);
  }
  void add_net_other_time(float net_other_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_NET_OTHER_TIME, net_other_time, 0.0f);
  }
  void add_gvt_time(float gvt_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_GVT_TIME, gvt_time, 0.0f);
  }
  void add_fc_time(float fc_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_FC_TIME, fc_time, 0.0f);
  }
  void add_event_abort_time(float event_abort_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_EVENT_ABORT_TIME, event_abort_time, 0.0f);
  }
  void add_event_proc_time(float event_proc_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_EVENT_PROC_TIME, event_proc_time, 0.0f);
  }
  void add_pq_time(float pq_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_PQ_TIME, pq_time, 0.0f);
  }
  void add_rb_time(float rb_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_RB_TIME, rb_time, 0.0f);
  }
  void add_cancel_q_time(float cancel_q_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_CANCEL_Q_TIME, cancel_q_time, 0.0f);
  }
  void add_avl_time(float avl_time) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_AVL_TIME, avl_time, 0.0f);
  }
  void add_virtual_time_diff(float virtual_time_diff) {
    fbb_.AddElement<float>(SimEngineMetrics::VT_VIRTUAL_TIME_DIFF, virtual_time_diff, 0.0f);
  }
  void add_comm_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> comm_data) {
    fbb_.AddOffset(SimEngineMetrics::VT_COMM_DATA, comm_data);
  }
  explicit SimEngineMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimEngineMetricsBuilder &operator=(const SimEngineMetricsBuilder &);
  flatbuffers::Offset<SimEngineMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimEngineMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimEngineMetrics> CreateSimEngineMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t nevent_processed = 0,
    int32_t nevent_abort = 0,
    int32_t nevent_rb = 0,
    int32_t rb_total = 0,
    int32_t rb_prim = 0,
    int32_t rb_sec = 0,
    int32_t fc_attempts = 0,
    int32_t pq_qsize = 0,
    int32_t network_send = 0,
    int32_t network_recv = 0,
    int32_t num_gvt = 0,
    int32_t event_ties = 0,
    float efficiency = 0.0f,
    float net_read_time = 0.0f,
    float net_other_time = 0.0f,
    float gvt_time = 0.0f,
    float fc_time = 0.0f,
    float event_abort_time = 0.0f,
    float event_proc_time = 0.0f,
    float pq_time = 0.0f,
    float rb_time = 0.0f,
    float cancel_q_time = 0.0f,
    float avl_time = 0.0f,
    float virtual_time_diff = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> comm_data = 0) {
  SimEngineMetricsBuilder builder_(_fbb);
  builder_.add_comm_data(comm_data);
  builder_.add_virtual_time_diff(virtual_time_diff);
  builder_.add_avl_time(avl_time);
  builder_.add_cancel_q_time(cancel_q_time);
  builder_.add_rb_time(rb_time);
  builder_.add_pq_time(pq_time);
  builder_.add_event_proc_time(event_proc_time);
  builder_.add_event_abort_time(event_abort_time);
  builder_.add_fc_time(fc_time);
  builder_.add_gvt_time(gvt_time);
  builder_.add_net_other_time(net_other_time);
  builder_.add_net_read_time(net_read_time);
  builder_.add_efficiency(efficiency);
  builder_.add_event_ties(event_ties);
  builder_.add_num_gvt(num_gvt);
  builder_.add_network_recv(network_recv);
  builder_.add_network_send(network_send);
  builder_.add_pq_qsize(pq_qsize);
  builder_.add_fc_attempts(fc_attempts);
  builder_.add_rb_sec(rb_sec);
  builder_.add_rb_prim(rb_prim);
  builder_.add_rb_total(rb_total);
  builder_.add_nevent_rb(nevent_rb);
  builder_.add_nevent_abort(nevent_abort);
  builder_.add_nevent_processed(nevent_processed);
  return builder_.Finish();
}

inline flatbuffers::Offset<SimEngineMetrics> CreateSimEngineMetricsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t nevent_processed = 0,
    int32_t nevent_abort = 0,
    int32_t nevent_rb = 0,
    int32_t rb_total = 0,
    int32_t rb_prim = 0,
    int32_t rb_sec = 0,
    int32_t fc_attempts = 0,
    int32_t pq_qsize = 0,
    int32_t network_send = 0,
    int32_t network_recv = 0,
    int32_t num_gvt = 0,
    int32_t event_ties = 0,
    float efficiency = 0.0f,
    float net_read_time = 0.0f,
    float net_other_time = 0.0f,
    float gvt_time = 0.0f,
    float fc_time = 0.0f,
    float event_abort_time = 0.0f,
    float event_proc_time = 0.0f,
    float pq_time = 0.0f,
    float rb_time = 0.0f,
    float cancel_q_time = 0.0f,
    float avl_time = 0.0f,
    float virtual_time_diff = 0.0f,
    const std::vector<int32_t> *comm_data = nullptr) {
  auto comm_data__ = comm_data ? _fbb.CreateVector<int32_t>(*comm_data) : 0;
  return ross_damaris::sample::CreateSimEngineMetrics(
      _fbb,
      nevent_processed,
      nevent_abort,
      nevent_rb,
      rb_total,
      rb_prim,
      rb_sec,
      fc_attempts,
      pq_qsize,
      network_send,
      network_recv,
      num_gvt,
      event_ties,
      efficiency,
      net_read_time,
      net_other_time,
      gvt_time,
      fc_time,
      event_abort_time,
      event_proc_time,
      pq_time,
      rb_time,
      cancel_q_time,
      avl_time,
      virtual_time_diff,
      comm_data__);
}

flatbuffers::Offset<SimEngineMetrics> CreateSimEngineMetrics(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LPDataT : public flatbuffers::NativeTable {
  typedef LPData TableType;
  int32_t peid;
  int32_t kpid;
  int32_t kp_gid;
  int32_t lpid;
  int32_t lp_gid;
  std::unique_ptr<SimEngineMetricsT> data;
  LPDataT()
      : peid(0),
        kpid(0),
        kp_gid(0),
        lpid(0),
        lp_gid(0) {
  }
};

struct LPData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LPDataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LPDataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEID = 4,
    VT_KPID = 6,
    VT_KP_GID = 8,
    VT_LPID = 10,
    VT_LP_GID = 12,
    VT_DATA = 14
  };
  int32_t peid() const {
    return GetField<int32_t>(VT_PEID, 0);
  }
  int32_t kpid() const {
    return GetField<int32_t>(VT_KPID, 0);
  }
  int32_t kp_gid() const {
    return GetField<int32_t>(VT_KP_GID, 0);
  }
  int32_t lpid() const {
    return GetField<int32_t>(VT_LPID, 0);
  }
  int32_t lp_gid() const {
    return GetField<int32_t>(VT_LP_GID, 0);
  }
  const SimEngineMetrics *data() const {
    return GetPointer<const SimEngineMetrics *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEID) &&
           VerifyField<int32_t>(verifier, VT_KPID) &&
           VerifyField<int32_t>(verifier, VT_KP_GID) &&
           VerifyField<int32_t>(verifier, VT_LPID) &&
           VerifyField<int32_t>(verifier, VT_LP_GID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
  LPDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LPDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LPData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LPDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peid(int32_t peid) {
    fbb_.AddElement<int32_t>(LPData::VT_PEID, peid, 0);
  }
  void add_kpid(int32_t kpid) {
    fbb_.AddElement<int32_t>(LPData::VT_KPID, kpid, 0);
  }
  void add_kp_gid(int32_t kp_gid) {
    fbb_.AddElement<int32_t>(LPData::VT_KP_GID, kp_gid, 0);
  }
  void add_lpid(int32_t lpid) {
    fbb_.AddElement<int32_t>(LPData::VT_LPID, lpid, 0);
  }
  void add_lp_gid(int32_t lp_gid) {
    fbb_.AddElement<int32_t>(LPData::VT_LP_GID, lp_gid, 0);
  }
  void add_data(flatbuffers::Offset<SimEngineMetrics> data) {
    fbb_.AddOffset(LPData::VT_DATA, data);
  }
  explicit LPDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LPDataBuilder &operator=(const LPDataBuilder &);
  flatbuffers::Offset<LPData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LPData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LPData> CreateLPData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t peid = 0,
    int32_t kpid = 0,
    int32_t kp_gid = 0,
    int32_t lpid = 0,
    int32_t lp_gid = 0,
    flatbuffers::Offset<SimEngineMetrics> data = 0) {
  LPDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_lp_gid(lp_gid);
  builder_.add_lpid(lpid);
  builder_.add_kp_gid(kp_gid);
  builder_.add_kpid(kpid);
  builder_.add_peid(peid);
  return builder_.Finish();
}

flatbuffers::Offset<LPData> CreateLPData(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KPDataT : public flatbuffers::NativeTable {
  typedef KPData TableType;
  int32_t peid;
  int32_t kpid;
  int32_t kp_gid;
  std::unique_ptr<SimEngineMetricsT> data;
  KPDataT()
      : peid(0),
        kpid(0),
        kp_gid(0) {
  }
};

struct KPData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KPDataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KPDataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEID = 4,
    VT_KPID = 6,
    VT_KP_GID = 8,
    VT_DATA = 10
  };
  int32_t peid() const {
    return GetField<int32_t>(VT_PEID, 0);
  }
  int32_t kpid() const {
    return GetField<int32_t>(VT_KPID, 0);
  }
  int32_t kp_gid() const {
    return GetField<int32_t>(VT_KP_GID, 0);
  }
  const SimEngineMetrics *data() const {
    return GetPointer<const SimEngineMetrics *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEID) &&
           VerifyField<int32_t>(verifier, VT_KPID) &&
           VerifyField<int32_t>(verifier, VT_KP_GID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
  KPDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KPDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KPData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KPDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peid(int32_t peid) {
    fbb_.AddElement<int32_t>(KPData::VT_PEID, peid, 0);
  }
  void add_kpid(int32_t kpid) {
    fbb_.AddElement<int32_t>(KPData::VT_KPID, kpid, 0);
  }
  void add_kp_gid(int32_t kp_gid) {
    fbb_.AddElement<int32_t>(KPData::VT_KP_GID, kp_gid, 0);
  }
  void add_data(flatbuffers::Offset<SimEngineMetrics> data) {
    fbb_.AddOffset(KPData::VT_DATA, data);
  }
  explicit KPDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KPDataBuilder &operator=(const KPDataBuilder &);
  flatbuffers::Offset<KPData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KPData>(end);
    return o;
  }
};

inline flatbuffers::Offset<KPData> CreateKPData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t peid = 0,
    int32_t kpid = 0,
    int32_t kp_gid = 0,
    flatbuffers::Offset<SimEngineMetrics> data = 0) {
  KPDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_kp_gid(kp_gid);
  builder_.add_kpid(kpid);
  builder_.add_peid(peid);
  return builder_.Finish();
}

flatbuffers::Offset<KPData> CreateKPData(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PEDataT : public flatbuffers::NativeTable {
  typedef PEData TableType;
  int32_t peid;
  std::unique_ptr<SimEngineMetricsT> data;
  PEDataT()
      : peid(0) {
  }
};

struct PEData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PEDataT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PEDataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEID = 4,
    VT_DATA = 6
  };
  int32_t peid() const {
    return GetField<int32_t>(VT_PEID, 0);
  }
  const SimEngineMetrics *data() const {
    return GetPointer<const SimEngineMetrics *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
  PEDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PEDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PEData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PEDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peid(int32_t peid) {
    fbb_.AddElement<int32_t>(PEData::VT_PEID, peid, 0);
  }
  void add_data(flatbuffers::Offset<SimEngineMetrics> data) {
    fbb_.AddOffset(PEData::VT_DATA, data);
  }
  explicit PEDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PEDataBuilder &operator=(const PEDataBuilder &);
  flatbuffers::Offset<PEData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PEData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PEData> CreatePEData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t peid = 0,
    flatbuffers::Offset<SimEngineMetrics> data = 0) {
  PEDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_peid(peid);
  return builder_.Finish();
}

flatbuffers::Offset<PEData> CreatePEData(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntVarT : public flatbuffers::NativeTable {
  typedef IntVar TableType;
  std::vector<int32_t> value;
  IntVarT() {
  }
};

struct IntVar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntVarT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntVarTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  IntVarT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntVarT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IntVar> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntVarT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntVarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(IntVar::VT_VALUE, value);
  }
  explicit IntVarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntVarBuilder &operator=(const IntVarBuilder &);
  flatbuffers::Offset<IntVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntVar>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntVar> CreateIntVar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> value = 0) {
  IntVarBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntVar> CreateIntVarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return ross_damaris::sample::CreateIntVar(
      _fbb,
      value__);
}

flatbuffers::Offset<IntVar> CreateIntVar(flatbuffers::FlatBufferBuilder &_fbb, const IntVarT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LongVarT : public flatbuffers::NativeTable {
  typedef LongVar TableType;
  std::vector<int64_t> value;
  LongVarT() {
  }
};

struct LongVar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LongVarT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LongVarTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int64_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  LongVarT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LongVarT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LongVar> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LongVarT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LongVarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int64_t>> value) {
    fbb_.AddOffset(LongVar::VT_VALUE, value);
  }
  explicit LongVarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LongVarBuilder &operator=(const LongVarBuilder &);
  flatbuffers::Offset<LongVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LongVar>(end);
    return o;
  }
};

inline flatbuffers::Offset<LongVar> CreateLongVar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> value = 0) {
  LongVarBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<LongVar> CreateLongVarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int64_t>(*value) : 0;
  return ross_damaris::sample::CreateLongVar(
      _fbb,
      value__);
}

flatbuffers::Offset<LongVar> CreateLongVar(flatbuffers::FlatBufferBuilder &_fbb, const LongVarT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloatVarT : public flatbuffers::NativeTable {
  typedef FloatVar TableType;
  std::vector<float> value;
  FloatVarT() {
  }
};

struct FloatVar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatVarT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloatVarTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  FloatVarT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatVarT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloatVar> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatVarT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatVarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(FloatVar::VT_VALUE, value);
  }
  explicit FloatVarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatVarBuilder &operator=(const FloatVarBuilder &);
  flatbuffers::Offset<FloatVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatVar>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatVar> CreateFloatVar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  FloatVarBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatVar> CreateFloatVarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return ross_damaris::sample::CreateFloatVar(
      _fbb,
      value__);
}

flatbuffers::Offset<FloatVar> CreateFloatVar(flatbuffers::FlatBufferBuilder &_fbb, const FloatVarT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DoubleVarT : public flatbuffers::NativeTable {
  typedef DoubleVar TableType;
  std::vector<double> value;
  DoubleVarT() {
  }
};

struct DoubleVar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleVarT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DoubleVarTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<double> *value() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  DoubleVarT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DoubleVarT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DoubleVar> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVarT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DoubleVarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<double>> value) {
    fbb_.AddOffset(DoubleVar::VT_VALUE, value);
  }
  explicit DoubleVarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleVarBuilder &operator=(const DoubleVarBuilder &);
  flatbuffers::Offset<DoubleVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleVar>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleVar> CreateDoubleVar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> value = 0) {
  DoubleVarBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoubleVar> CreateDoubleVarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<double>(*value) : 0;
  return ross_damaris::sample::CreateDoubleVar(
      _fbb,
      value__);
}

flatbuffers::Offset<DoubleVar> CreateDoubleVar(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVarT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelVariableT : public flatbuffers::NativeTable {
  typedef ModelVariable TableType;
  std::string var_name;
  VariableTypeUnion var_value;
  ModelVariableT() {
  }
};

struct ModelVariable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelVariableT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModelVariableTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAR_NAME = 4,
    VT_VAR_VALUE_TYPE = 6,
    VT_VAR_VALUE = 8
  };
  const flatbuffers::String *var_name() const {
    return GetPointer<const flatbuffers::String *>(VT_VAR_NAME);
  }
  VariableType var_value_type() const {
    return static_cast<VariableType>(GetField<uint8_t>(VT_VAR_VALUE_TYPE, 0));
  }
  const void *var_value() const {
    return GetPointer<const void *>(VT_VAR_VALUE);
  }
  template<typename T> const T *var_value_as() const;
  const IntVar *var_value_as_IntVar() const {
    return var_value_type() == VariableType_IntVar ? static_cast<const IntVar *>(var_value()) : nullptr;
  }
  const LongVar *var_value_as_LongVar() const {
    return var_value_type() == VariableType_LongVar ? static_cast<const LongVar *>(var_value()) : nullptr;
  }
  const FloatVar *var_value_as_FloatVar() const {
    return var_value_type() == VariableType_FloatVar ? static_cast<const FloatVar *>(var_value()) : nullptr;
  }
  const DoubleVar *var_value_as_DoubleVar() const {
    return var_value_type() == VariableType_DoubleVar ? static_cast<const DoubleVar *>(var_value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VAR_NAME) &&
           verifier.VerifyString(var_name()) &&
           VerifyField<uint8_t>(verifier, VT_VAR_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VAR_VALUE) &&
           VerifyVariableType(verifier, var_value(), var_value_type()) &&
           verifier.EndTable();
  }
  ModelVariableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelVariableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ModelVariable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelVariableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const IntVar *ModelVariable::var_value_as<IntVar>() const {
  return var_value_as_IntVar();
}

template<> inline const LongVar *ModelVariable::var_value_as<LongVar>() const {
  return var_value_as_LongVar();
}

template<> inline const FloatVar *ModelVariable::var_value_as<FloatVar>() const {
  return var_value_as_FloatVar();
}

template<> inline const DoubleVar *ModelVariable::var_value_as<DoubleVar>() const {
  return var_value_as_DoubleVar();
}

struct ModelVariableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_var_name(flatbuffers::Offset<flatbuffers::String> var_name) {
    fbb_.AddOffset(ModelVariable::VT_VAR_NAME, var_name);
  }
  void add_var_value_type(VariableType var_value_type) {
    fbb_.AddElement<uint8_t>(ModelVariable::VT_VAR_VALUE_TYPE, static_cast<uint8_t>(var_value_type), 0);
  }
  void add_var_value(flatbuffers::Offset<void> var_value) {
    fbb_.AddOffset(ModelVariable::VT_VAR_VALUE, var_value);
  }
  explicit ModelVariableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelVariableBuilder &operator=(const ModelVariableBuilder &);
  flatbuffers::Offset<ModelVariable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelVariable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelVariable> CreateModelVariable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> var_name = 0,
    VariableType var_value_type = VariableType_NONE,
    flatbuffers::Offset<void> var_value = 0) {
  ModelVariableBuilder builder_(_fbb);
  builder_.add_var_value(var_value);
  builder_.add_var_name(var_name);
  builder_.add_var_value_type(var_value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModelVariable> CreateModelVariableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *var_name = nullptr,
    VariableType var_value_type = VariableType_NONE,
    flatbuffers::Offset<void> var_value = 0) {
  auto var_name__ = var_name ? _fbb.CreateString(var_name) : 0;
  return ross_damaris::sample::CreateModelVariable(
      _fbb,
      var_name__,
      var_value_type,
      var_value);
}

flatbuffers::Offset<ModelVariable> CreateModelVariable(flatbuffers::FlatBufferBuilder &_fbb, const ModelVariableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelLPT : public flatbuffers::NativeTable {
  typedef ModelLP TableType;
  int32_t lpid;
  std::string lptype;
  std::vector<std::unique_ptr<ModelVariableT>> variables;
  ModelLPT()
      : lpid(0) {
  }
};

struct ModelLP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelLPT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModelLPTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LPID = 4,
    VT_LPTYPE = 6,
    VT_VARIABLES = 8
  };
  int32_t lpid() const {
    return GetField<int32_t>(VT_LPID, 0);
  }
  const flatbuffers::String *lptype() const {
    return GetPointer<const flatbuffers::String *>(VT_LPTYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ModelVariable>> *variables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ModelVariable>> *>(VT_VARIABLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LPID) &&
           VerifyOffset(verifier, VT_LPTYPE) &&
           verifier.VerifyString(lptype()) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(variables()) &&
           verifier.VerifyVectorOfTables(variables()) &&
           verifier.EndTable();
  }
  ModelLPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelLPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ModelLP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelLPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelLPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lpid(int32_t lpid) {
    fbb_.AddElement<int32_t>(ModelLP::VT_LPID, lpid, 0);
  }
  void add_lptype(flatbuffers::Offset<flatbuffers::String> lptype) {
    fbb_.AddOffset(ModelLP::VT_LPTYPE, lptype);
  }
  void add_variables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ModelVariable>>> variables) {
    fbb_.AddOffset(ModelLP::VT_VARIABLES, variables);
  }
  explicit ModelLPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelLPBuilder &operator=(const ModelLPBuilder &);
  flatbuffers::Offset<ModelLP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelLP>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelLP> CreateModelLP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lpid = 0,
    flatbuffers::Offset<flatbuffers::String> lptype = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ModelVariable>>> variables = 0) {
  ModelLPBuilder builder_(_fbb);
  builder_.add_variables(variables);
  builder_.add_lptype(lptype);
  builder_.add_lpid(lpid);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModelLP> CreateModelLPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lpid = 0,
    const char *lptype = nullptr,
    const std::vector<flatbuffers::Offset<ModelVariable>> *variables = nullptr) {
  auto lptype__ = lptype ? _fbb.CreateString(lptype) : 0;
  auto variables__ = variables ? _fbb.CreateVector<flatbuffers::Offset<ModelVariable>>(*variables) : 0;
  return ross_damaris::sample::CreateModelLP(
      _fbb,
      lpid,
      lptype__,
      variables__);
}

flatbuffers::Offset<ModelLP> CreateModelLP(flatbuffers::FlatBufferBuilder &_fbb, const ModelLPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DamarisDataSampleT : public flatbuffers::NativeTable {
  typedef DamarisDataSample TableType;
  double virtual_ts;
  double real_ts;
  double last_gvt;
  InstMode mode;
  std::vector<std::unique_ptr<PEDataT>> pe_data;
  std::vector<std::unique_ptr<KPDataT>> kp_data;
  std::vector<std::unique_ptr<LPDataT>> lp_data;
  std::vector<std::unique_ptr<ModelLPT>> model_data;
  int32_t entity_id;
  int32_t event_id;
  DataStatus status;
  DamarisDataSampleT()
      : virtual_ts(0.0),
        real_ts(0.0),
        last_gvt(0.0),
        mode(InstMode_none),
        entity_id(-1),
        event_id(-1),
        status(DataStatus_speculative) {
  }
};

struct DamarisDataSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DamarisDataSampleT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DamarisDataSampleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VIRTUAL_TS = 4,
    VT_REAL_TS = 6,
    VT_LAST_GVT = 8,
    VT_MODE = 10,
    VT_PE_DATA = 12,
    VT_KP_DATA = 14,
    VT_LP_DATA = 16,
    VT_MODEL_DATA = 18,
    VT_ENTITY_ID = 20,
    VT_EVENT_ID = 22,
    VT_STATUS = 24
  };
  double virtual_ts() const {
    return GetField<double>(VT_VIRTUAL_TS, 0.0);
  }
  double real_ts() const {
    return GetField<double>(VT_REAL_TS, 0.0);
  }
  double last_gvt() const {
    return GetField<double>(VT_LAST_GVT, 0.0);
  }
  InstMode mode() const {
    return static_cast<InstMode>(GetField<int32_t>(VT_MODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<PEData>> *pe_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PEData>> *>(VT_PE_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<KPData>> *kp_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KPData>> *>(VT_KP_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LPData>> *lp_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LPData>> *>(VT_LP_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ModelLP>> *model_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ModelLP>> *>(VT_MODEL_DATA);
  }
  /// next three used for internal info
  int32_t entity_id() const {
    return GetField<int32_t>(VT_ENTITY_ID, -1);
  }
  int32_t event_id() const {
    return GetField<int32_t>(VT_EVENT_ID, -1);
  }
  DataStatus status() const {
    return static_cast<DataStatus>(GetField<int32_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VIRTUAL_TS) &&
           VerifyField<double>(verifier, VT_REAL_TS) &&
           VerifyField<double>(verifier, VT_LAST_GVT) &&
           VerifyField<int32_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_PE_DATA) &&
           verifier.VerifyVector(pe_data()) &&
           verifier.VerifyVectorOfTables(pe_data()) &&
           VerifyOffset(verifier, VT_KP_DATA) &&
           verifier.VerifyVector(kp_data()) &&
           verifier.VerifyVectorOfTables(kp_data()) &&
           VerifyOffset(verifier, VT_LP_DATA) &&
           verifier.VerifyVector(lp_data()) &&
           verifier.VerifyVectorOfTables(lp_data()) &&
           VerifyOffset(verifier, VT_MODEL_DATA) &&
           verifier.VerifyVector(model_data()) &&
           verifier.VerifyVectorOfTables(model_data()) &&
           VerifyField<int32_t>(verifier, VT_ENTITY_ID) &&
           VerifyField<int32_t>(verifier, VT_EVENT_ID) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
  DamarisDataSampleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DamarisDataSampleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DamarisDataSample> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DamarisDataSampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_virtual_ts(double virtual_ts) {
    fbb_.AddElement<double>(DamarisDataSample::VT_VIRTUAL_TS, virtual_ts, 0.0);
  }
  void add_real_ts(double real_ts) {
    fbb_.AddElement<double>(DamarisDataSample::VT_REAL_TS, real_ts, 0.0);
  }
  void add_last_gvt(double last_gvt) {
    fbb_.AddElement<double>(DamarisDataSample::VT_LAST_GVT, last_gvt, 0.0);
  }
  void add_mode(InstMode mode) {
    fbb_.AddElement<int32_t>(DamarisDataSample::VT_MODE, static_cast<int32_t>(mode), 0);
  }
  void add_pe_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PEData>>> pe_data) {
    fbb_.AddOffset(DamarisDataSample::VT_PE_DATA, pe_data);
  }
  void add_kp_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KPData>>> kp_data) {
    fbb_.AddOffset(DamarisDataSample::VT_KP_DATA, kp_data);
  }
  void add_lp_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LPData>>> lp_data) {
    fbb_.AddOffset(DamarisDataSample::VT_LP_DATA, lp_data);
  }
  void add_model_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ModelLP>>> model_data) {
    fbb_.AddOffset(DamarisDataSample::VT_MODEL_DATA, model_data);
  }
  void add_entity_id(int32_t entity_id) {
    fbb_.AddElement<int32_t>(DamarisDataSample::VT_ENTITY_ID, entity_id, -1);
  }
  void add_event_id(int32_t event_id) {
    fbb_.AddElement<int32_t>(DamarisDataSample::VT_EVENT_ID, event_id, -1);
  }
  void add_status(DataStatus status) {
    fbb_.AddElement<int32_t>(DamarisDataSample::VT_STATUS, static_cast<int32_t>(status), 0);
  }
  explicit DamarisDataSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DamarisDataSampleBuilder &operator=(const DamarisDataSampleBuilder &);
  flatbuffers::Offset<DamarisDataSample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DamarisDataSample>(end);
    return o;
  }
};

inline flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSample(
    flatbuffers::FlatBufferBuilder &_fbb,
    double virtual_ts = 0.0,
    double real_ts = 0.0,
    double last_gvt = 0.0,
    InstMode mode = InstMode_none,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PEData>>> pe_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KPData>>> kp_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LPData>>> lp_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ModelLP>>> model_data = 0,
    int32_t entity_id = -1,
    int32_t event_id = -1,
    DataStatus status = DataStatus_speculative) {
  DamarisDataSampleBuilder builder_(_fbb);
  builder_.add_last_gvt(last_gvt);
  builder_.add_real_ts(real_ts);
  builder_.add_virtual_ts(virtual_ts);
  builder_.add_status(status);
  builder_.add_event_id(event_id);
  builder_.add_entity_id(entity_id);
  builder_.add_model_data(model_data);
  builder_.add_lp_data(lp_data);
  builder_.add_kp_data(kp_data);
  builder_.add_pe_data(pe_data);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double virtual_ts = 0.0,
    double real_ts = 0.0,
    double last_gvt = 0.0,
    InstMode mode = InstMode_none,
    const std::vector<flatbuffers::Offset<PEData>> *pe_data = nullptr,
    const std::vector<flatbuffers::Offset<KPData>> *kp_data = nullptr,
    const std::vector<flatbuffers::Offset<LPData>> *lp_data = nullptr,
    const std::vector<flatbuffers::Offset<ModelLP>> *model_data = nullptr,
    int32_t entity_id = -1,
    int32_t event_id = -1,
    DataStatus status = DataStatus_speculative) {
  auto pe_data__ = pe_data ? _fbb.CreateVector<flatbuffers::Offset<PEData>>(*pe_data) : 0;
  auto kp_data__ = kp_data ? _fbb.CreateVector<flatbuffers::Offset<KPData>>(*kp_data) : 0;
  auto lp_data__ = lp_data ? _fbb.CreateVector<flatbuffers::Offset<LPData>>(*lp_data) : 0;
  auto model_data__ = model_data ? _fbb.CreateVector<flatbuffers::Offset<ModelLP>>(*model_data) : 0;
  return ross_damaris::sample::CreateDamarisDataSample(
      _fbb,
      virtual_ts,
      real_ts,
      last_gvt,
      mode,
      pe_data__,
      kp_data__,
      lp_data__,
      model_data__,
      entity_id,
      event_id,
      status);
}

flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSample(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SimEngineMetricsT *SimEngineMetrics::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SimEngineMetricsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SimEngineMetrics::UnPackTo(SimEngineMetricsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nevent_processed(); _o->nevent_processed = _e; };
  { auto _e = nevent_abort(); _o->nevent_abort = _e; };
  { auto _e = nevent_rb(); _o->nevent_rb = _e; };
  { auto _e = rb_total(); _o->rb_total = _e; };
  { auto _e = rb_prim(); _o->rb_prim = _e; };
  { auto _e = rb_sec(); _o->rb_sec = _e; };
  { auto _e = fc_attempts(); _o->fc_attempts = _e; };
  { auto _e = pq_qsize(); _o->pq_qsize = _e; };
  { auto _e = network_send(); _o->network_send = _e; };
  { auto _e = network_recv(); _o->network_recv = _e; };
  { auto _e = num_gvt(); _o->num_gvt = _e; };
  { auto _e = event_ties(); _o->event_ties = _e; };
  { auto _e = efficiency(); _o->efficiency = _e; };
  { auto _e = net_read_time(); _o->net_read_time = _e; };
  { auto _e = net_other_time(); _o->net_other_time = _e; };
  { auto _e = gvt_time(); _o->gvt_time = _e; };
  { auto _e = fc_time(); _o->fc_time = _e; };
  { auto _e = event_abort_time(); _o->event_abort_time = _e; };
  { auto _e = event_proc_time(); _o->event_proc_time = _e; };
  { auto _e = pq_time(); _o->pq_time = _e; };
  { auto _e = rb_time(); _o->rb_time = _e; };
  { auto _e = cancel_q_time(); _o->cancel_q_time = _e; };
  { auto _e = avl_time(); _o->avl_time = _e; };
  { auto _e = virtual_time_diff(); _o->virtual_time_diff = _e; };
  { auto _e = comm_data(); if (_e) { _o->comm_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->comm_data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<SimEngineMetrics> SimEngineMetrics::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSimEngineMetrics(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SimEngineMetrics> CreateSimEngineMetrics(flatbuffers::FlatBufferBuilder &_fbb, const SimEngineMetricsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SimEngineMetricsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nevent_processed = _o->nevent_processed;
  auto _nevent_abort = _o->nevent_abort;
  auto _nevent_rb = _o->nevent_rb;
  auto _rb_total = _o->rb_total;
  auto _rb_prim = _o->rb_prim;
  auto _rb_sec = _o->rb_sec;
  auto _fc_attempts = _o->fc_attempts;
  auto _pq_qsize = _o->pq_qsize;
  auto _network_send = _o->network_send;
  auto _network_recv = _o->network_recv;
  auto _num_gvt = _o->num_gvt;
  auto _event_ties = _o->event_ties;
  auto _efficiency = _o->efficiency;
  auto _net_read_time = _o->net_read_time;
  auto _net_other_time = _o->net_other_time;
  auto _gvt_time = _o->gvt_time;
  auto _fc_time = _o->fc_time;
  auto _event_abort_time = _o->event_abort_time;
  auto _event_proc_time = _o->event_proc_time;
  auto _pq_time = _o->pq_time;
  auto _rb_time = _o->rb_time;
  auto _cancel_q_time = _o->cancel_q_time;
  auto _avl_time = _o->avl_time;
  auto _virtual_time_diff = _o->virtual_time_diff;
  auto _comm_data = _o->comm_data.size() ? _fbb.CreateVector(_o->comm_data) : 0;
  return ross_damaris::sample::CreateSimEngineMetrics(
      _fbb,
      _nevent_processed,
      _nevent_abort,
      _nevent_rb,
      _rb_total,
      _rb_prim,
      _rb_sec,
      _fc_attempts,
      _pq_qsize,
      _network_send,
      _network_recv,
      _num_gvt,
      _event_ties,
      _efficiency,
      _net_read_time,
      _net_other_time,
      _gvt_time,
      _fc_time,
      _event_abort_time,
      _event_proc_time,
      _pq_time,
      _rb_time,
      _cancel_q_time,
      _avl_time,
      _virtual_time_diff,
      _comm_data);
}

inline LPDataT *LPData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LPDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LPData::UnPackTo(LPDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peid(); _o->peid = _e; };
  { auto _e = kpid(); _o->kpid = _e; };
  { auto _e = kp_gid(); _o->kp_gid = _e; };
  { auto _e = lpid(); _o->lpid = _e; };
  { auto _e = lp_gid(); _o->lp_gid = _e; };
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<SimEngineMetricsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<LPData> LPData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLPData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LPData> CreateLPData(flatbuffers::FlatBufferBuilder &_fbb, const LPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LPDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peid = _o->peid;
  auto _kpid = _o->kpid;
  auto _kp_gid = _o->kp_gid;
  auto _lpid = _o->lpid;
  auto _lp_gid = _o->lp_gid;
  auto _data = _o->data ? CreateSimEngineMetrics(_fbb, _o->data.get(), _rehasher) : 0;
  return ross_damaris::sample::CreateLPData(
      _fbb,
      _peid,
      _kpid,
      _kp_gid,
      _lpid,
      _lp_gid,
      _data);
}

inline KPDataT *KPData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new KPDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void KPData::UnPackTo(KPDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peid(); _o->peid = _e; };
  { auto _e = kpid(); _o->kpid = _e; };
  { auto _e = kp_gid(); _o->kp_gid = _e; };
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<SimEngineMetricsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<KPData> KPData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKPData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KPData> CreateKPData(flatbuffers::FlatBufferBuilder &_fbb, const KPDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KPDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peid = _o->peid;
  auto _kpid = _o->kpid;
  auto _kp_gid = _o->kp_gid;
  auto _data = _o->data ? CreateSimEngineMetrics(_fbb, _o->data.get(), _rehasher) : 0;
  return ross_damaris::sample::CreateKPData(
      _fbb,
      _peid,
      _kpid,
      _kp_gid,
      _data);
}

inline PEDataT *PEData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PEDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PEData::UnPackTo(PEDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peid(); _o->peid = _e; };
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<SimEngineMetricsT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<PEData> PEData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePEData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PEData> CreatePEData(flatbuffers::FlatBufferBuilder &_fbb, const PEDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PEDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peid = _o->peid;
  auto _data = _o->data ? CreateSimEngineMetrics(_fbb, _o->data.get(), _rehasher) : 0;
  return ross_damaris::sample::CreatePEData(
      _fbb,
      _peid,
      _data);
}

inline IntVarT *IntVar::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IntVarT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IntVar::UnPackTo(IntVarT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<IntVar> IntVar::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntVarT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntVar(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IntVar> CreateIntVar(flatbuffers::FlatBufferBuilder &_fbb, const IntVarT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IntVarT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return ross_damaris::sample::CreateIntVar(
      _fbb,
      _value);
}

inline LongVarT *LongVar::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LongVarT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LongVar::UnPackTo(LongVarT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<LongVar> LongVar::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LongVarT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLongVar(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LongVar> CreateLongVar(flatbuffers::FlatBufferBuilder &_fbb, const LongVarT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LongVarT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return ross_damaris::sample::CreateLongVar(
      _fbb,
      _value);
}

inline FloatVarT *FloatVar::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FloatVarT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FloatVar::UnPackTo(FloatVarT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<FloatVar> FloatVar::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatVarT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloatVar(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloatVar> CreateFloatVar(flatbuffers::FlatBufferBuilder &_fbb, const FloatVarT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloatVarT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return ross_damaris::sample::CreateFloatVar(
      _fbb,
      _value);
}

inline DoubleVarT *DoubleVar::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DoubleVarT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DoubleVar::UnPackTo(DoubleVarT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<DoubleVar> DoubleVar::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVarT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDoubleVar(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DoubleVar> CreateDoubleVar(flatbuffers::FlatBufferBuilder &_fbb, const DoubleVarT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DoubleVarT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return ross_damaris::sample::CreateDoubleVar(
      _fbb,
      _value);
}

inline ModelVariableT *ModelVariable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ModelVariableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ModelVariable::UnPackTo(ModelVariableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = var_name(); if (_e) _o->var_name = _e->str(); };
  { auto _e = var_value_type(); _o->var_value.type = _e; };
  { auto _e = var_value(); if (_e) _o->var_value.value = VariableTypeUnion::UnPack(_e, var_value_type(), _resolver); };
}

inline flatbuffers::Offset<ModelVariable> ModelVariable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelVariableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModelVariable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ModelVariable> CreateModelVariable(flatbuffers::FlatBufferBuilder &_fbb, const ModelVariableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelVariableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _var_name = _o->var_name.empty() ? 0 : _fbb.CreateString(_o->var_name);
  auto _var_value_type = _o->var_value.type;
  auto _var_value = _o->var_value.Pack(_fbb);
  return ross_damaris::sample::CreateModelVariable(
      _fbb,
      _var_name,
      _var_value_type,
      _var_value);
}

inline ModelLPT *ModelLP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ModelLPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ModelLP::UnPackTo(ModelLPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lpid(); _o->lpid = _e; };
  { auto _e = lptype(); if (_e) _o->lptype = _e->str(); };
  { auto _e = variables(); if (_e) { _o->variables.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variables[_i] = std::unique_ptr<ModelVariableT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ModelLP> ModelLP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelLPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModelLP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ModelLP> CreateModelLP(flatbuffers::FlatBufferBuilder &_fbb, const ModelLPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelLPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lpid = _o->lpid;
  auto _lptype = _o->lptype.empty() ? 0 : _fbb.CreateString(_o->lptype);
  auto _variables = _o->variables.size() ? _fbb.CreateVector<flatbuffers::Offset<ModelVariable>> (_o->variables.size(), [](size_t i, _VectorArgs *__va) { return CreateModelVariable(*__va->__fbb, __va->__o->variables[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ross_damaris::sample::CreateModelLP(
      _fbb,
      _lpid,
      _lptype,
      _variables);
}

inline DamarisDataSampleT *DamarisDataSample::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DamarisDataSampleT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DamarisDataSample::UnPackTo(DamarisDataSampleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = virtual_ts(); _o->virtual_ts = _e; };
  { auto _e = real_ts(); _o->real_ts = _e; };
  { auto _e = last_gvt(); _o->last_gvt = _e; };
  { auto _e = mode(); _o->mode = _e; };
  { auto _e = pe_data(); if (_e) { _o->pe_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pe_data[_i] = std::unique_ptr<PEDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kp_data(); if (_e) { _o->kp_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kp_data[_i] = std::unique_ptr<KPDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = lp_data(); if (_e) { _o->lp_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lp_data[_i] = std::unique_ptr<LPDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = model_data(); if (_e) { _o->model_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->model_data[_i] = std::unique_ptr<ModelLPT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = entity_id(); _o->entity_id = _e; };
  { auto _e = event_id(); _o->event_id = _e; };
  { auto _e = status(); _o->status = _e; };
}

inline flatbuffers::Offset<DamarisDataSample> DamarisDataSample::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDamarisDataSample(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DamarisDataSample> CreateDamarisDataSample(flatbuffers::FlatBufferBuilder &_fbb, const DamarisDataSampleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DamarisDataSampleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _virtual_ts = _o->virtual_ts;
  auto _real_ts = _o->real_ts;
  auto _last_gvt = _o->last_gvt;
  auto _mode = _o->mode;
  auto _pe_data = _o->pe_data.size() ? _fbb.CreateVector<flatbuffers::Offset<PEData>> (_o->pe_data.size(), [](size_t i, _VectorArgs *__va) { return CreatePEData(*__va->__fbb, __va->__o->pe_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kp_data = _o->kp_data.size() ? _fbb.CreateVector<flatbuffers::Offset<KPData>> (_o->kp_data.size(), [](size_t i, _VectorArgs *__va) { return CreateKPData(*__va->__fbb, __va->__o->kp_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lp_data = _o->lp_data.size() ? _fbb.CreateVector<flatbuffers::Offset<LPData>> (_o->lp_data.size(), [](size_t i, _VectorArgs *__va) { return CreateLPData(*__va->__fbb, __va->__o->lp_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _model_data = _o->model_data.size() ? _fbb.CreateVector<flatbuffers::Offset<ModelLP>> (_o->model_data.size(), [](size_t i, _VectorArgs *__va) { return CreateModelLP(*__va->__fbb, __va->__o->model_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _entity_id = _o->entity_id;
  auto _event_id = _o->event_id;
  auto _status = _o->status;
  return ross_damaris::sample::CreateDamarisDataSample(
      _fbb,
      _virtual_ts,
      _real_ts,
      _last_gvt,
      _mode,
      _pe_data,
      _kp_data,
      _lp_data,
      _model_data,
      _entity_id,
      _event_id,
      _status);
}

inline bool VerifyVariableType(flatbuffers::Verifier &verifier, const void *obj, VariableType type) {
  switch (type) {
    case VariableType_NONE: {
      return true;
    }
    case VariableType_IntVar: {
      auto ptr = reinterpret_cast<const IntVar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariableType_LongVar: {
      auto ptr = reinterpret_cast<const LongVar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariableType_FloatVar: {
      auto ptr = reinterpret_cast<const FloatVar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariableType_DoubleVar: {
      auto ptr = reinterpret_cast<const DoubleVar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyVariableTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVariableType(
        verifier,  values->Get(i), types->GetEnum<VariableType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *VariableTypeUnion::UnPack(const void *obj, VariableType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case VariableType_IntVar: {
      auto ptr = reinterpret_cast<const IntVar *>(obj);
      return ptr->UnPack(resolver);
    }
    case VariableType_LongVar: {
      auto ptr = reinterpret_cast<const LongVar *>(obj);
      return ptr->UnPack(resolver);
    }
    case VariableType_FloatVar: {
      auto ptr = reinterpret_cast<const FloatVar *>(obj);
      return ptr->UnPack(resolver);
    }
    case VariableType_DoubleVar: {
      auto ptr = reinterpret_cast<const DoubleVar *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> VariableTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case VariableType_IntVar: {
      auto ptr = reinterpret_cast<const IntVarT *>(value);
      return CreateIntVar(_fbb, ptr, _rehasher).Union();
    }
    case VariableType_LongVar: {
      auto ptr = reinterpret_cast<const LongVarT *>(value);
      return CreateLongVar(_fbb, ptr, _rehasher).Union();
    }
    case VariableType_FloatVar: {
      auto ptr = reinterpret_cast<const FloatVarT *>(value);
      return CreateFloatVar(_fbb, ptr, _rehasher).Union();
    }
    case VariableType_DoubleVar: {
      auto ptr = reinterpret_cast<const DoubleVarT *>(value);
      return CreateDoubleVar(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline VariableTypeUnion::VariableTypeUnion(const VariableTypeUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case VariableType_IntVar: {
      value = new IntVarT(*reinterpret_cast<IntVarT *>(u.value));
      break;
    }
    case VariableType_LongVar: {
      value = new LongVarT(*reinterpret_cast<LongVarT *>(u.value));
      break;
    }
    case VariableType_FloatVar: {
      value = new FloatVarT(*reinterpret_cast<FloatVarT *>(u.value));
      break;
    }
    case VariableType_DoubleVar: {
      value = new DoubleVarT(*reinterpret_cast<DoubleVarT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void VariableTypeUnion::Reset() {
  switch (type) {
    case VariableType_IntVar: {
      auto ptr = reinterpret_cast<IntVarT *>(value);
      delete ptr;
      break;
    }
    case VariableType_LongVar: {
      auto ptr = reinterpret_cast<LongVarT *>(value);
      delete ptr;
      break;
    }
    case VariableType_FloatVar: {
      auto ptr = reinterpret_cast<FloatVarT *>(value);
      delete ptr;
      break;
    }
    case VariableType_DoubleVar: {
      auto ptr = reinterpret_cast<DoubleVarT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = VariableType_NONE;
}

inline const flatbuffers::TypeTable *InstModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    InstModeTypeTable
  };
  static const char * const names[] = {
    "none",
    "GVT",
    "VT",
    "RT",
    "ET"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DataStatusTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataStatusTypeTable
  };
  static const char * const names[] = {
    "speculative",
    "committed",
    "invalid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VariableTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    IntVarTypeTable,
    LongVarTypeTable,
    FloatVarTypeTable,
    DoubleVarTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "IntVar",
    "LongVar",
    "FloatVar",
    "DoubleVar"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SimEngineMetricsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "nevent_processed",
    "nevent_abort",
    "nevent_rb",
    "rb_total",
    "rb_prim",
    "rb_sec",
    "fc_attempts",
    "pq_qsize",
    "network_send",
    "network_recv",
    "num_gvt",
    "event_ties",
    "efficiency",
    "net_read_time",
    "net_other_time",
    "gvt_time",
    "fc_time",
    "event_abort_time",
    "event_proc_time",
    "pq_time",
    "rb_time",
    "cancel_q_time",
    "avl_time",
    "virtual_time_diff",
    "comm_data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 25, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LPDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SimEngineMetricsTypeTable
  };
  static const char * const names[] = {
    "peid",
    "kpid",
    "kp_gid",
    "lpid",
    "lp_gid",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KPDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SimEngineMetricsTypeTable
  };
  static const char * const names[] = {
    "peid",
    "kpid",
    "kp_gid",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PEDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SimEngineMetricsTypeTable
  };
  static const char * const names[] = {
    "peid",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntVarTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LongVarTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloatVarTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DoubleVarTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ModelVariableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    VariableTypeTypeTable
  };
  static const char * const names[] = {
    "var_name",
    "var_value_type",
    "var_value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ModelLPTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ModelVariableTypeTable
  };
  static const char * const names[] = {
    "lpid",
    "lptype",
    "variables"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DamarisDataSampleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 5 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    InstModeTypeTable,
    PEDataTypeTable,
    KPDataTypeTable,
    LPDataTypeTable,
    ModelLPTypeTable,
    DataStatusTypeTable
  };
  static const char * const names[] = {
    "virtual_ts",
    "real_ts",
    "last_gvt",
    "mode",
    "pe_data",
    "kp_data",
    "lp_data",
    "model_data",
    "entity_id",
    "event_id",
    "status"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const ross_damaris::sample::DamarisDataSample *GetDamarisDataSample(const void *buf) {
  return flatbuffers::GetRoot<ross_damaris::sample::DamarisDataSample>(buf);
}

inline const ross_damaris::sample::DamarisDataSample *GetSizePrefixedDamarisDataSample(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ross_damaris::sample::DamarisDataSample>(buf);
}

inline bool VerifyDamarisDataSampleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ross_damaris::sample::DamarisDataSample>(nullptr);
}

inline bool VerifySizePrefixedDamarisDataSampleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ross_damaris::sample::DamarisDataSample>(nullptr);
}

inline void FinishDamarisDataSampleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ross_damaris::sample::DamarisDataSample> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDamarisDataSampleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ross_damaris::sample::DamarisDataSample> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<DamarisDataSampleT> UnPackDamarisDataSample(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DamarisDataSampleT>(GetDamarisDataSample(buf)->UnPack(res));
}

}  // namespace sample
}  // namespace ross_damaris

#endif  // FLATBUFFERS_GENERATED_DATASAMPLE_ROSS_DAMARIS_SAMPLE_H_
